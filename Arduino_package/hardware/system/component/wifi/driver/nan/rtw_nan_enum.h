
#ifndef __RTW_NAN_ENUM_H_
#define __RTW_NAN_ENUM_H_

enum nan_get_srvc_by_e {
	GET_SRVC_BY_COOKIE          = BIT(0),
	GET_SRVC_BY_SRVC_ID         = BIT(1),
	GET_SRVC_BY_SRVC_TYPE       = BIT(2),
	GET_SRVC_BY_INST_ID         = BIT(3),
	GET_SRVC_BY_FIRST_SRVC_ID   = BIT(5),
};

enum nan_pkt_type_e {
	NAN_PKT_TYPE_NONE	= 0x0,
	NAN_PKT_TYPE_SDF		= 0x2,
	NAN_PKT_TYPE_DATA	= 0x3,
	NAN_PKT_TYPE_NAF		= 0x4,
};

enum nan_srvc_type_e {
	NAN_SRVC_TYPE_NONE				  	= 0x0,
	NAN_SRVC_TYPE_UNSOLICITED_PUBLISH 	= 0x1,
	NAN_SRVC_TYPE_SOLICITED_PUBLISH   	= 0x2,
	NAN_SRVC_TYPE_ACTIVE_SUBSCRIBE    	= 0x3,
	NAN_SRVC_TYPE_PASSIVE_SUBSCRIBE   	= 0x4,
	NAN_SRVC_TYPE_FOLLOW_UP			  	= 0x5,
};

enum ndp_setup_secure_msg_e {
	NDP_SEC_INSTALL_M1	= 1,
	NDP_SEC_INSTALL_M2	= 2,
	NDP_SEC_INSTALL_M3	= 3,
	NDP_SEC_INSTALL_M4	= 4
};

enum nan_cmd_type {
	/* NAN cmd type */
	NAN_CMD_TYPE_NONE 		= 0,
	NAN_CMD_TYPE_NATIVE_IW 	= 1,
	NAN_CMD_TYPE_NANDOW 	= 2
};

enum rtw_nan_event_type {
	RTW_NAN_EVENT_NONE				= 0x0,
	RTW_NAN_EVT_NEXT_DW				= 0x1,
	RTW_NAN_EVT_SCHDL_REJECT_NEW			= 0x3,
	RTW_NAN_EVT_SEND_NDL_RSP_CFRM_ACCEPT_EVENT		= 0x4,
	RTW_NAN_EVT_SCHDL_APPLY_NEW_TIME_MAP	= 0x5,
	RTW_NAN_EVT_DATA_SEND_NDP_FRAME		= 0x7,
	RTW_NAN_EVT_DATA_PEER_NDP_EMPTY			= 0x9,
	RTW_NAN_EVT_CLEAR_PEER_INFO		= 0xb,
	RTW_NAN_EVT_DISC_SDF_REPLAY				= 0xc,
	RTW_NAN_EVT_SCHDL_WITHDRAW_FW_SCHDL			= 0xd,
	RTW_NAN_EVT_DATA_BSTRAP_COMEBACK			= 0x11,
	RTW_NAN_EVT_DATA_NDP_ACCEPT			= 0x14,
	RTW_NAN_EVT_CLUSTER_CHANGED			= 0x15,
};

enum nan_publish_type {
	NAN_SOLICITED_PUBLISH = BIT0,
	NAN_UNSOLICITED_PUBLISH = BIT1,
};

enum nan_publish_solicited_tx_type {
	NAN_SOLICITED_TX_MULTICAST = 1,	// spec definition
	NAN_SOLICITED_TX_UNICAST = 2,	// spec definition
	NAN_SOLICITED_TX_BROADCAST = 3	// @publish_bcast: if true, the solicited publish should be broadcasted (cfg80211)
};

enum nan_auto_reply_followup_type {
	TYPE_NAN_AUTO_FOLLOWUP_MAC_ADDR = 1,
	TYPE_NAN_AUTO_FOLLOWUP_IPV6 	= 2,
	TYPE_NAN_AUTO_FOLLOWUP_TALK 	= 3
};

enum nan_service_termination_reason {
	NAN_SERVICE_TERMINATION_REASON_TIME_OUT       = 1,
	NAN_SERVICE_TERMINATION_REASON_USER_INITIATED = 2,
	NAN_SERVICE_TERMINATION_REASON_FAILURE        = 3,
	NAN_SERVICE_TERMINATION_REASON_CHIP_RESET     = 4,
	NAN_SERVICE_TERMINATION_REASON_NAN_DISABLE    = 5,
	NAN_SERVICE_TERMINATION_REASON_CHIP_REJECT    = 6,
};

#ifdef CONFIG_NAN_PAIRING
/* share with vendor_wrapper */
enum nan_tx_follow_up_type {
	NAN_TX_FOLLOW_UP_NONE,
	NAN_TX_FOLLOW_UP_GENERAL,
	NAN_TX_FOLLOW_UP_BSTRP,
	NAN_TX_FOLLOW_UP_REQ,
	NAN_TX_FOLLOW_UP_RSP,
	NAN_TX_FOLLOW_UP_MAX
};
enum nan_tx_follow_up_key_type {
	NAN_TX_FOLLOW_UP_SEC_GTK      = BIT0,
	NAN_TX_FOLLOW_UP_SEC_IGTK     = BIT1,
	NAN_TX_FOLLOW_UP_SEC_BIGTK    = BIT2,
	NAN_TX_FOLLOW_UP_SEC_NIK      = BIT3,
	NAN_TX_FOLLOW_UP_SEC_ND_TK    = BIT4,
	NAN_TX_FOLLOW_UP_SEC_NM_TK    = BIT5,
};

#endif

enum nan_cipher_suite {
	NCS_SK_128 = 0,
	NCS_SK_256
};

enum nan_peer_ndp_nego_state {
	NDP_NEGO_STATE_NONE = 0,
	NDP_NEGO_STATE_SEND_REQ,
	NDP_NEGO_STATE_RECV_REQ,
	NDP_NEGO_STATE_SEND_RSP,
	NDP_NEGO_STATE_CONFIRM_REQUIRED,
	NDP_NEGO_STATE_RECV_RSP,
	NDP_NEGO_STATE_SEND_CONFIRM,
	NDP_NEGO_STATE_RECV_CONFIRM,
	NDP_NEGO_STATE_SEND_SEC_INSTALL,
	NDP_NEGO_STATE_RECV_SEC_INSTALL,
	NDP_NEGO_STATE_SEND_TERMINATE,
	NDP_NEGO_STATE_RECV_TERMINATE
};

enum nan_peer_ndl_or_ndp_status {
	NDL_OR_NDP_STATUS_CONTINUE = 0,
	NDL_OR_NDP_STATUS_ACCEPT,
	NDL_OR_NDP_STATUS_REJECT,
	NDL_OR_NDP_STATUS_NONE
};

enum nan_pairing_role {
	PAIRING_ROLE_INITIATOR = 1,
	PAIRING_ROLE_RESPONDER,
};

enum nan_pairing_type {
	PAIRING_TYPE_NONE = 0,
	PAIRING_TYPE_SETUP = 1,
	PAIRING_TYPE_VERIFICATION,
};

enum nan_pairing_auth {
	PAIRING_AUTH_PW = 1,  /* password */
	PAIRING_AUTH_OPP,     /* opportunistic */
};

enum nan_pasn_phase {
	NAN_PASN_NONE,
	NAN_PASN_SEND_1,
	NAN_PASN_SEND_2,
	NAN_PASN_SEND_3,
	NAN_PASN_DONE
};

enum nan_nik_exchange_status {
	NIK_EX_NONE = 0,
	NIK_EX_DONE,
	NIK_EX_TIMEOUT
};

enum nan_data_qos_types {
	NAN_DATA_QOS_TYPE_ADAPTIVE    = 0,   // Slots&Channel will adapt based on traffic, channel utilization, etc */
	NAN_DATA_QOS_TYPE_TIER_1      = 1,   // 12.5% availability
	NAN_DATA_QOS_TYPE_TIER_2      = 2,   // 25% availability
	NAN_DATA_QOS_TYPE_TIER_3      = 3,   // 50% availability
	NAN_DATA_QOS_TYPE_TIER_4      = 4,   // 75% availability
	NAN_DATA_QOS_TYPE_TIER_5      = 5,   // 100% availability, No empty slots, all slots will have a valid channel
	NAN_DATA_QOS_TYPE_REAL_TIME   = NAN_DATA_QOS_TYPE_TIER_5,
};

enum nan_ndp_role {
	NDP_ROLE_INITIATOR = 0,
	NDP_ROLE_RESPONDER = 1,
};

enum nan_gtk_crypt_type {
	NAN_CRYPT_TYPE_GTK     = 1,
	NAN_CRYPT_TYPE_IGTK    = 2,
	NAN_CRYPT_TYPE_BIGTK   = 3,
};

enum nan_gtk_cap {
	NAN_GTK_NONE             = 0,
	NAN_GTK_IGTK_SUP         = 1,
	NAN_GTK_IGTK_BIGTK_SUP   = 2,
};

enum nan_key_lifetime_bitmap {
	NAN_KEY_LIFTIME_GTK      = BIT0,
	NAN_KEY_LIFTIME_IGTK     = BIT1,
	NAN_KEY_LIFTIME_BIGTK    = BIT2,
	NAN_KEY_LIFTIME_NIK      = BIT3,
	NAN_KEY_LIFTIME_ND_TK    = BIT4,
	NAN_KEY_LIFTIME_NM_TK    = BIT5,
};

enum nan_pmk_setting {
	NAN_PMK_SET_BY_USER	= 1,
	NAN_PMK_SET_BY_PASSPRHRAE,
	NAN_PMK_SET_BY_PAIRING
};

#ifdef CONFIG_NAN_PAIRING
enum nan_bstrap_phase {
	NAN_BSTRAP_NONE,
	NAN_BSTRAP_SEND_REQ,
	NAN_BSTRAP_SEND_RSP_COMEBACK,
	NAN_BSTRAP_RECV_RSP_COMEBACK,
	NAN_BSTRAP_SEND_REQ_COMEBACK,
	NAN_BSTRAP_DONE
};

enum nan_bstrap_method {
	NAN_BSTRAP_METHOD_OPPORTUNISTIC = BIT0,
	NAN_BSTRAP_METHOD_PIN_CODE_DISP = BIT1,
	NAN_BSTRAP_METHOD_PASSPHRASE_DISP = BIT2,
	NAN_BSTRAP_METHOD_QR_CODE_DISP = BIT3,
	NAN_BSTRAP_METHOD_NFC_TAG = BIT4,
	NAN_BSTRAP_METHOD_PIN_CODE_KEYPAD = BIT5,
	NAN_BSTRAP_METHOD_PASSPHRASE_KEYPAD = BIT6,
	NAN_BSTRAP_METHOD_QR_CODE_SCAN = BIT7,
	NAN_BSTRAP_METHOD_NFC_READER = BIT8,
	NAN_BSTRAP_METHOD_SRVC_MGNT = BIT14,
	NAN_BSTRAP_METHOD_SKIP = BIT15
};
#endif

enum nan_vht_sc {
	VHT_DATA_SC_DONOT_CARE = 0,
	VHT_DATA_SC_20_UPPER_OF_80MHZ = 1,
	VHT_DATA_SC_20_LOWER_OF_80MHZ = 2,
	VHT_DATA_SC_20_UPPERST_OF_80MHZ = 3,
	VHT_DATA_SC_20_LOWEST_OF_80MHZ = 4,
};


enum nan_avil_entry_type {
	AVAIL_ENTRY_TYPE_COMMITTED = BIT0,
	AVAIL_ENTRY_TYPE_POTENTIAL = BIT1,
	AVAIL_ENTRY_TYPE_CONDITIONAL = BIT2,
};

enum nan_avil_entry_type_flag {
	AVAIL_ENTRY_TYPE_FLAG_ISSUE_SDF = BIT0,
	AVAIL_ENTRY_TYPE_FLAG_ISSUE_NAF = BIT1,
	AVAIL_ENTRY_TYPE_FLAG_NEGO_ONGOING = BIT2,
};

enum nan_reason_code {
	UNSPECIFIED_REASON		= 1,
	RESOURCE_LIMITATION		= 2,
	INVALID_PARAMETERS		= 3,
	FTM_PARAMETERS_INCAPABLE	= 4,
	NO_MOVEMENT			= 5,
	INVALID_AVAILABILITY		= 6,
	IMMUTABLE_UNACCEPTABLE		= 7,
	SECURITY_POLICY			= 8,
	QOS_UNACCEPTABLE		= 9,
	NDP_REJECTED			= 10,
	NDL_UNACCEPTABLE		= 11,
	RANGING_SCHEDULE_UNACCEPTABLE	= 12,
	PAIRING_BOOTSTRAPPING_REJECTED	= 13,
};

enum nan_band_id {
	BAND_ID_24G = 2,
	BAND_ID_5G = 4
};

enum ndl_nego_state {
	NDL_NEGO_STATE_NONE = 0,
	NDL_NEGO_STATE_SEND_REQ,
	NDL_NEGO_STATE_RECV_REQ,
	NDL_NEGO_STATE_SEND_RSP,
	NDL_NEGO_STATE_CONFIRM_REQUIRED,
	NDL_NEGO_STATE_RECV_RSP,
	NDL_NEGO_STATE_SEND_CONFIRM,
	NDL_NEGO_STATE_RECV_CONFIRM,
	NDL_NEGO_STATE_SEND_UPDATE,
	NDL_NEGO_STATE_RECV_UPDATE
};

enum nan_time_map_slot_status {
	SLOT_STATUS_AVAILABLE = 0x0,
	SLOT_STATUS_CONDITIONAL_ALLOW = 0x1,
	SLOT_STATUS_CONDITIONAL_BLOCK = 0x2,
	SLOT_STATUS_BLOCK = 0x3,
	/* make sure following check status at the buttom of enum*/
	SLOT_STATUS_CHECKED_AVAIL,
	SLOT_STATUS_CHECKED_COND_ALLOW,
	SLOT_STATUS_CHECKED_COND_BLOCK,
	SLOT_STATUS_CHECKED_BLOCK,
};

enum nan_schdl_pattern_e {
	NAN_SCHDL_PATTERN_NONE = 0x0,
	NAN_SCHDL_PATTERN_SIGNLE_ROLE_CONCURRENT,
	NAN_SCHDL_PATTERN_SIGNLE_ROLE_CONCURRENT_EN_CH_SEL,
	NAN_SCHDL_PATTERN_MULTIPLE_ROLE_CONCURRENT
};
#endif /* __RTW_NAN_ENUM_H_ */